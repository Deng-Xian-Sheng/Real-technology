2025/05/31 07:50æ›´æ–°

æˆ‘é€šè¿‡å¤šæ¬¡æµ‹è¯•ä»£ç åœ¨ã€Šé›¨å¤©ã€‹ä¸­çš„è¡¨ç°ï¼Œé‡‡å–äº†ä¸€äº›é™ä½å»¶è¿Ÿçš„æ–¹æ³•ã€‚

æˆ‘é‡‡ç”¨äº†ï¼š

- é™ä½å›¾ç‰‡åˆ†è¾¨ç‡
- ä»å†å²æ¶ˆæ¯ä¸­å»é™¤å›¾ç‰‡ï¼Œåªè®©å½“å‰æ¶ˆæ¯å¸¦æœ‰å›¾ç‰‡ï¼ˆæœ€æ–°ä¸€æ¡æ¶ˆæ¯ï¼‰
- ä¸è¯»å†™ç£ç›˜ï¼Œå°†å›¾ç‰‡æ”¾åœ¨bufferä¸­è€Œä¸æ˜¯å†™å…¥åˆ°æ–‡ä»¶

æ˜¾è‘—é™ä½å»¶è¿Ÿçš„æ–¹æ³•æ˜¯é™ä½å›¾ç‰‡åˆ†è¾¨ç‡ï¼Œå»¶è¿Ÿä»5.8ï½8ç§’é™ä½åˆ°3.8ï½5ç§’ï¼Œæ³¢åŠ¨è¾ƒå¤§å¯èƒ½æ˜¯å› ä¸ºç½‘ç»œåŸå› ï¼Œæš‚ä¸æ¸…æ¥šã€‚

æ˜¾è‘—é™ä½å»¶è¿Ÿçš„åŒæ—¶ï¼Œåˆ†è¾¨ç‡å¤§å¹…åº¦ä¸‹é™ã€‚

![image](https://github.com/user-attachments/assets/4eb9d2b8-e6a7-4d84-a5b0-4d698f0c6916)

å¯¹äº†ï¼Œæˆ‘è¿˜æ·»åŠ äº†åˆ†æè¯·æ±‚LLMå»¶è¿Ÿçš„ä»£ç ï¼Œæœ‰åˆ©äºä½ ä»¬åˆ†æã€è°ƒè¯•ã€‚

ä¸‹é¢æ˜¯å»é™¤â€œå¯¹äºã€Šé›¨å¤©ã€‹çš„å®šåˆ¶æç¤ºè¯â€ä¹‹åçš„ä»£ç ï¼š

```python
import openai
import pyautogui
import time
import json
import base64
import pygetwindow as gw
from pynput.keyboard import Key, Controller
import io

# === é…ç½® ===
keyboard = Controller()
openaiclient = openai.OpenAI(base_url="https://text.pollinations.ai/openai",api_key="kfc111")
WINDOWS_TITLE = "Rainy Day"
DEFAULT_LOOP_INTERVAL = 2
MIN_LOOP_INTERVAL = 0.5
MAX_LOOP_INTERVAL = 5.0

# === å·¥å…·å®šä¹‰ ===
tools = [
    {
        "type": "function",
        "function": {
            "name": "press_key",
            "description": "æ¨¡æ‹ŸæŒ‰ä¸‹é”®ç›˜æŒ‰é”®æ¥æ§åˆ¶æ¸¸æˆï¼Œå¯ä»¥è®¾ç½®æŒ‰é”®æŒç»­æ—¶é—´",
            "parameters": {
                "type": "object",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "è¦æŒ‰ä¸‹çš„é”®åã€‚å¸¸ç”¨é”®åŒ…æ‹¬ï¼šæ–¹å‘é”®(up/down/left/right)ã€ç©ºæ ¼é”®(space)ã€å­—æ¯é”®(a-z)ã€æ•°å­—é”®(0-9)ç­‰"
                    },
                    "duration": {
                        "type": "number",
                        "description": "æŒ‰ä½é”®çš„æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰ã€‚ç”¨äºé•¿æŒ‰æ“ä½œï¼Œå¦‚0.5è¡¨ç¤ºæŒ‰ä½0.5ç§’",
                        "default": 0.1
                    }
                },
                "required": ["key"]
            }
        }
    }
]

# === å·¥å…·å‡½æ•° ===
def screenshot_and_encode():
    windows = gw.getWindowsWithTitle(WINDOWS_TITLE)
    if not windows:
        raise Exception(f"æœªæ‰¾åˆ°æ ‡é¢˜ä¸º\"{WINDOWS_TITLE}\"çš„çª—å£")
    win = windows[0]
    win.activate()
    bbox = (win.left, win.top, win.width, win.height)
    img = pyautogui.screenshot(region=bbox)
    img = img.resize((480, 270))  # é™ä½åˆ†è¾¨ç‡è‡³480x270
    
    # ç›´æ¥åœ¨å†…å­˜ä¸­è½¬æ¢ä¸ºbase64ï¼Œé¿å…ç£ç›˜è¯»å†™
    buffer = io.BytesIO()
    img.save(buffer, format="JPEG", quality=50)  # é™ä½JPEGè´¨é‡è‡³50%
    # debug
    img.save("debug.jpg", format="JPEG", quality=50)
    return base64.b64encode(buffer.getvalue()).decode()
   
def execute_key_action(key: str, duration: float = 0.1):
    print(f"â¹ æŒ‰ä¸‹ {key} é”®ï¼ŒæŒç»­ {duration:.1f} ç§’")
    try:
        special_keys = {
            'space': Key.space,
            'enter': Key.enter,
            'return': Key.enter,
            'shift': Key.shift,
            'ctrl': Key.ctrl,
            'control': Key.ctrl,
            'alt': Key.alt,
            'esc': Key.esc,
            'escape': Key.esc,
            'tab': Key.tab,
            'up': Key.up,
            'â†‘': Key.up,
            'down': Key.down,
            'â†“': Key.down,
            'left': Key.left,
            'â†': Key.left,
            'right': Key.right,
            'â†’': Key.right,
            'backspace': Key.backspace,
            'delete': Key.delete,
            'home': Key.home,
            'end': Key.end,
            'pageup': Key.page_up,
            'pagedown': Key.page_down,
        }
        key_normalized = key.strip().lower()
        mapped_key = special_keys.get(key_normalized, key_normalized)
        keyboard.press(mapped_key)
        time.sleep(duration)
        keyboard.release(mapped_key)
    except Exception as e:
        print(f"âš ï¸ é”®ç›˜æ“ä½œå¤±è´¥: {e}")

def handle_tool_call(call):
    name = call.function.name
    args = json.loads(call.function.arguments)
    if name == "press_key":
        execute_key_action(args["key"], args.get("duration", 0.1))
        return True
    return False

# === ä¸»å¾ªç¯ ===
def main_loop():
    loop_interval = DEFAULT_LOOP_INTERVAL
    print("ğŸ® å¼€å§‹æ™ºèƒ½ä½“å¾ªç¯ï¼Œæ¯è½®é—´éš”", loop_interval, "ç§’")
    
    # åˆå§‹åŒ–å¯¹è¯å†å²ï¼Œä¿æŒä¸å˜
    conversation_history = [
    {
        "role": "system", 
        "content": """ä½ æ˜¯ä¸€ä½æ¸¸æˆæ™ºèƒ½ä½“ï¼Œèƒ½é€šè¿‡è§‚å¯Ÿæ¸¸æˆç”»é¢å¹¶æ§åˆ¶é”®ç›˜æ¥ç©æ¸¸æˆã€‚

ã€ç›®æ ‡ã€‘
1. åˆ†ææ¸¸æˆç”»é¢ï¼Œç†è§£æ¸¸æˆè§„åˆ™å’Œæ“ä½œæ–¹å¼
2. æ‰§è¡Œæ°å½“çš„æŒ‰é”®æ“ä½œä»¥å®Œæˆæ¸¸æˆç›®æ ‡
3. åœ¨æ¯æ¬¡å›å¤ä¸­æä¾›æ¸¸æˆçŠ¶æ€åˆ†æå’Œæ“ä½œç†ç”±

ã€è¾“å‡ºæ ¼å¼ã€‘
æ¯æ¬¡å›å¤å¿…é¡»åŒ…å«ä¸¤éƒ¨åˆ†ï¼š
1. æ–‡æœ¬åˆ†æï¼šç®€æ˜æè¿°å½“å‰æ¸¸æˆçŠ¶æ€ã€ä½ ç†è§£çš„è§„åˆ™å’Œä½ è¦æ‰§è¡Œæ“ä½œçš„åŸå› 
2. å·¥å…·è°ƒç”¨ï¼šä½¿ç”¨press_keyå·¥å…·æ‰§è¡Œä¸€æ¬¡é”®ç›˜æ“ä½œ

ç¤ºä¾‹å›å¤ï¼š
"æˆ‘çœ‹åˆ°è§’è‰²ç«™åœ¨å¹³å°è¾¹ç¼˜ï¼Œå‰æ–¹æœ‰éšœç¢ã€‚æ ¹æ®ä¹‹å‰çš„å°è¯•ï¼ŒæŒ‰ç©ºæ ¼é”®å¯ä»¥è·³è·ƒã€‚æˆ‘å°†æŒ‰ç©ºæ ¼é”®è·³è¿‡éšœç¢ç‰©ã€‚"

ã€é‡è¦è§„åˆ™ã€‘
- æ¯æ¬¡å›å¤å¿…é¡»åŒæ—¶åŒ…å«æ–‡æœ¬åˆ†æå’Œä¸€æ¬¡press_keyå·¥å…·è°ƒç”¨
- åŸºäºå½“å‰æ¸¸æˆç”»é¢çŠ¶æ€åšå‡ºå†³ç­–ï¼Œè€ƒè™‘ä¹‹å‰å­¦åˆ°çš„æ¸¸æˆè§„åˆ™
- å›å¤ç®€æ´æ˜äº†ï¼Œä¸è¶…è¿‡3-4å¥è¯"""
    }
]

    # è®°å½•APIè¯·æ±‚å»¶è¿Ÿç»Ÿè®¡
    api_latencies = []

    while True:
        try:
            # Step 1: è·å–å½“å‰æˆªå›¾çš„base64ç¼–ç 
            image_b64 = screenshot_and_encode()

            # å¤„ç†å†å²è®°å½•ä¸­çš„å›¾ç‰‡æ•°æ®
            for i in range(len(conversation_history)):
                if conversation_history[i]["role"] == "user" and isinstance(conversation_history[i]["content"], list):
                    # ç§»é™¤å†å²ç”¨æˆ·æ¶ˆæ¯ä¸­çš„å›¾ç‰‡ï¼Œåªä¿ç•™æ–‡æœ¬
                    text_content = next((item["text"] for item in conversation_history[i]["content"] 
                                        if item["type"] == "text"), "")
                    conversation_history[i]["content"] = text_content

            # Step 2: æ·»åŠ æ–°çš„ç”¨æˆ·æ¶ˆæ¯ï¼ˆæ¸¸æˆç”»é¢ï¼‰
            user_message = {
                "role": "user", 
                "content": [
                    {"type": "text", "text": "è¿™æ˜¯æ¸¸æˆå½“å‰ç”»é¢ï¼Œè¯·åˆ†ææƒ…å†µå¹¶æ‰§è¡Œä¸€æ¬¡åˆé€‚çš„æŒ‰é”®æ“ä½œã€‚"},
                    {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{image_b64}"}}
                ]
            }
            conversation_history.append(user_message)
            
            # ä¿®å¤çš„å†å²è£å‰ªé€»è¾‘ - æŒ‰æ¶ˆæ¯å¯¹ä¿ç•™å®Œæ•´
            if len(conversation_history) > 11:  # å†å²è¿‡é•¿éœ€è¦è£å‰ª
                # ä¿ç•™ç³»ç»Ÿæ¶ˆæ¯
                new_history = [conversation_history[0]]
                
                # ä»æœ€æ–°æ¶ˆæ¯å¼€å§‹ï¼ŒæŒ‰ç…§å®Œæ•´çš„è¯·æ±‚-å“åº”-å·¥å…·å¯¹æ·»åŠ 
                remaining_slots = 10  # 11ä¸ªæ€»æ§½ä½å‡å»ç³»ç»Ÿæ¶ˆæ¯
                i = len(conversation_history) - 1
                
                # ä¸´æ—¶å­˜å‚¨æ¶ˆæ¯ç»„
                message_groups = []
                
                # ä»æœ€æ–°åˆ°æœ€æ—©éå†æ¶ˆæ¯
                while i > 0 and remaining_slots > 0:
                    msg = conversation_history[i]
                    
                    # 1. å¤„ç†toolæ¶ˆæ¯
                    if msg["role"] == "tool":
                        tool_call_id = msg.get("tool_call_id")
                        # æ‰¾åˆ°å¯¹åº”çš„assistantæ¶ˆæ¯
                        for j in range(i-1, 0, -1):
                            if (conversation_history[j]["role"] == "assistant" and 
                                conversation_history[j].get("tool_calls") and 
                                any(call.id == tool_call_id for call in conversation_history[j].get("tool_calls", []))):
                                # æ‰¾åˆ°ç”¨æˆ·æ¶ˆæ¯(åœ¨assistantä¹‹å‰)
                                for k in range(j-1, 0, -1):
                                    if conversation_history[k]["role"] == "user":
                                        # æ‰¾åˆ°å®Œæ•´çš„ç”¨æˆ·-åŠ©æ‰‹-å·¥å…·å¯¹
                                        group = [conversation_history[k], conversation_history[j], msg]
                                        if len(group) <= remaining_slots:
                                            message_groups.append(group)
                                            remaining_slots -= len(group)
                                        i = k - 1
                                        break
                                break
                        
                    # 2. å¤„ç†ç‹¬ç«‹çš„ç”¨æˆ·-åŠ©æ‰‹å¯¹
                    elif msg["role"] == "assistant" and not msg.get("tool_calls"):
                        # å¯»æ‰¾å¯¹åº”çš„useræ¶ˆæ¯
                        for j in range(i-1, 0, -1):
                            if conversation_history[j]["role"] == "user":
                                group = [conversation_history[j], msg]
                                if len(group) <= remaining_slots:
                                    message_groups.append(group)
                                    remaining_slots -= len(group)
                                i = j - 1
                                break
                    
                    # 3. å¤„ç†å­¤ç«‹æ¶ˆæ¯æ—¶è·³è¿‡
                    else:
                        i -= 1
                
                # æŒ‰ä»æ—§åˆ°æ–°çš„é¡ºåºæ·»åŠ æ¶ˆæ¯ç»„
                message_groups.reverse()
                for group in message_groups:
                    new_history.extend(group)
                
                conversation_history = new_history
            
            # Step 3: è¯·æ±‚æ¨¡å‹
            # åœ¨è¯·æ±‚å‰éªŒè¯å†å²è®°å½•å®Œæ•´æ€§
            def validate_and_fix_history(history):
                # æ£€æŸ¥æ‰€æœ‰assistantå·¥å…·è°ƒç”¨æ˜¯å¦éƒ½æœ‰å“åº”
                fixed_history = []
                skip_ids = set()
                
                # ç¬¬ä¸€æ­¥ï¼šè¯†åˆ«æ²¡æœ‰å¯¹åº”å“åº”çš„å·¥å…·è°ƒç”¨ID
                for i, msg in enumerate(history):
                    if msg["role"] == "assistant" and msg.get("tool_calls"):
                        for call in msg.get("tool_calls", []):
                            has_response = False
                            for resp in history:
                                if resp["role"] == "tool" and resp.get("tool_call_id") == call.id:
                                    has_response = True
                                    break
                            if not has_response:
                                skip_ids.add(call.id)
                
                # ç¬¬äºŒæ­¥ï¼šè¿‡æ»¤å†å²è®°å½•
                for msg in history:
                    # è·³è¿‡æ²¡æœ‰å“åº”çš„assistantå·¥å…·è°ƒç”¨
                    if msg["role"] == "assistant" and msg.get("tool_calls"):
                        # æ·±æ‹·è´é¿å…ä¿®æ”¹åŸå§‹æ¶ˆæ¯
                        new_msg = dict(msg)
                        if "tool_calls" in new_msg:
                            new_tool_calls = []
                            for call in new_msg["tool_calls"]:
                                if call.id not in skip_ids:
                                    new_tool_calls.append(call)
                            
                            # å¦‚æœæ‰€æœ‰å·¥å…·è°ƒç”¨è¢«ç§»é™¤ï¼Œä¿ç•™æ–‡æœ¬å†…å®¹
                            if not new_tool_calls:
                                new_msg.pop("tool_calls", None)
                            else:
                                new_msg["tool_calls"] = new_tool_calls
                        
                        fixed_history.append(new_msg)
                    else:
                        # è·³è¿‡æ²¡æœ‰å¯¹åº”assistantçš„å·¥å…·å“åº”
                        if msg["role"] == "tool":
                            if msg.get("tool_call_id") in skip_ids:
                                continue
                        fixed_history.append(msg)
                
                return fixed_history
            
            # éªŒè¯å¹¶ä¿®å¤å†å²è®°å½•
            conversation_history = validate_and_fix_history(conversation_history)
            
            # å¼€å§‹è®¡æ—¶APIè¯·æ±‚
            api_start_time = time.time()

            response = openaiclient.chat.completions.create(
                model="openai-large",
                messages=conversation_history,
                tools=tools,
                tool_choice="auto"
            )

            # ç»“æŸè®¡æ—¶APIè¯·æ±‚
            api_end_time = time.time()
            api_latency = api_end_time - api_start_time
            api_latencies.append(api_latency)
            
            # è®¡ç®—å¹³å‡å»¶è¿Ÿ
            avg_latency = sum(api_latencies) / len(api_latencies)
            
            # è¾“å‡ºå»¶è¿Ÿä¿¡æ¯
            print(f"ğŸ“Š APIè¯·æ±‚å»¶è¿Ÿ: {api_latency:.2f}ç§’ (å¹³å‡: {avg_latency:.2f}ç§’)")

            reply = response.choices[0].message
            
            # æ‰“å°æ¨¡å‹å›å¤
            print("ğŸ§  æ¨¡å‹å“åº”:", getattr(reply, "content", "").strip())

            # ä¿å­˜åŠ©æ‰‹å›å¤åˆ°å†å²
            assistant_message = {
                "role": "assistant",
                "content": getattr(reply, "content", ""),
                "tool_calls": reply.tool_calls if hasattr(reply, "tool_calls") else None
            }
            conversation_history.append(assistant_message)
            
            # Step 4: å·¥å…·è°ƒç”¨å’Œæ·»åŠ å·¥å…·å“åº”
            did_act = False
            if hasattr(reply, "tool_calls") and reply.tool_calls:
                for call in reply.tool_calls:
                    success = handle_tool_call(call)
                    did_act = did_act or success
                    
                    # æ— æ¡ä»¶æ·»åŠ å·¥å…·å“åº”æ¶ˆæ¯ï¼Œç¡®ä¿æ¯ä¸ªå·¥å…·è°ƒç”¨éƒ½æœ‰å“åº”
                    tool_response_message = {
                        "role": "tool",
                        "tool_call_id": call.id,
                        "content": json.dumps({"success": success})
                    }
                    conversation_history.append(tool_response_message)

            # Step 5: åŠ¨æ€é—´éš”è°ƒèŠ‚
            loop_interval = max(MIN_LOOP_INTERVAL, min(MAX_LOOP_INTERVAL, 1.0 if did_act else 3.0))

        except Exception as e:
            print("âš ï¸ é”™è¯¯ï¼š", e)

        time.sleep(loop_interval)

if __name__ == "__main__":
    main_loop()
```

---

2025/05/31 00:46æ›´æ–°

æˆ‘ç¼–å†™äº†ï¼Œå¯¹äºã€Šé›¨å¤©ã€‹çš„å®šåˆ¶æç¤ºè¯ï¼š

```
ã€æ¸¸æˆæ“ä½œã€‘
- å¯¹äºæ¸¸æˆå¯ç”¨æ“ä½œï¼Œå§‹ç»ˆéµå¾ªä»¥ä¸‹å†…å®¹ï¼š
- æ²¡æœ‰è·³è·ƒï¼Œä¸è¦è·³è·ƒï¼
- æ¸¸æˆå¼€å§‹çš„æ—¶å€™ï¼Œéœ€è¦æŒ‰Fæ¥è¿›è¡Œä¸‹ä¸€æ­¥
- æ¸¸æˆé€šè¿‡leftã€rightæ¥å·¦å³ç§»åŠ¨
- æ¸¸æˆé€šè¿‡Fæ¥ä¸npcèŠå¤©ã€æ‰“å¼€æˆ¿é—¨ã€ç‚¹ç‡ƒç¯ç«/ç«ç‚‰ï¼Œå½“ç•Œé¢ä¸­æ²¡æœ‰æ˜¾ç¤ºé»„è‰²åº•è‰²çš„Fæ—¶ï¼Œè¯´æ˜æ²¡æœ‰äº¤äº’å¯¹è±¡
- æ¸¸æˆé€šè¿‡Sæ¥æ’‘ä¼ä»¥é˜²æ­¢é›¨æ°´æ·‹æ¹¿
- å½“æ±½è½¦æˆ–è€…è‡ªè¡Œè½¦æ¥ä¸´æ—¶ï¼Œéœ€è¦æ’‘ä¼
- æ¸¸æˆé€šè¿‡è¿›å…¥æˆ¿é—´/ç‚¹ç‡ƒç¯ç«æ¥ç¼“å’Œé›¨æ°´æ·‹æ¹¿
- å¦‚æœè¢«æ·‹æ¹¿æ¸¸æˆäººç‰©ä¼šæ˜¾ç¤ºæœ‰æ°´ï¼Œæ°´æ»¡äº†æ¸¸æˆä¼šå¤±è´¥
- ä½ åº”ä¼˜å…ˆå¾€rightèµ°ï¼Œä»¥é€šå…³æ¸¸æˆ
- å·¦å³ç§»åŠ¨æŒç»­æ—¶é•¿ï¼Œæœ€å¥½åœ¨2ç§’å·¦å³
```

---

è¿™æ®µä»£ç é€‚ç”¨äºé€šè¿‡é”®ç›˜æ§åˆ¶çš„æ¸¸æˆï¼Œæ¨¡å‹ä¼šæ ¹æ®æ¸¸æˆä¸­çš„é”®ä½æŒ‡å¼•ï¼ˆä¹Ÿå¯ä»¥æ²¡æœ‰ï¼‰è‡ªåŠ¨æ¸¸ç©æ¸¸æˆã€‚

è¿™æ®µä»£ç ä¸»è¦æ˜¯ä¸º `æ¥è‡ªæ£®Treeå¼€å‘çš„ã€Šé›¨å¤©ã€‹` æ¸¸æˆè®¾è®¡çš„ï¼Œä½†æ˜¯ï¼Œå®ƒæ²¡æœ‰ä¸è¯¥æ¸¸æˆæ·±åº¦ç»‘å®šï¼Œæ‰€ä»¥é€‚ç”¨äºå…¶ä»–é”®ç›˜æ§åˆ¶çš„å°æ¸¸æˆã€‚

ç†è®ºä¸Šä»£ç æ‰€ä½¿ç”¨çš„åº“æ˜¯è·¨å¹³å°çš„ï¼Œä½†æ˜¯æˆ‘åªåœ¨windowså¹³å°ä¸Šæµ‹è¯•äº†å®ƒã€‚

æ¨¡å‹ä½¿ç”¨äº†OpenAI GPT-4.1ï¼Œåœ¨OpenAI GPT-4.1ä¸Šè¡¨ç°æœ€ä½³ï¼Œåœ¨OpenAI GPT-4.1-nanoä¸Šè¡¨ç°ç›¸å¯¹è¾ƒå·®ã€‚

ä¸ºäº†æ›´å¥½çš„è®©æ¨¡å‹æ¸¸ç©ä½ çš„æ¸¸æˆï¼Œä½ éœ€è¦ä¿®æ”¹ä»£ç ï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„æ¨¡å‹å‡½æ•°è°ƒç”¨ï¼Œä¾‹å¦‚ï¼šè®°äº‹æœ¬ã€‚è®©æ¨¡å‹è®°å½•æ¸¸ç©ä¸­çš„å¤±è´¥å’Œæœ‰ç”¨çš„ä¿¡æ¯ï¼Œå®ç°æ›´å¥½çš„æ¸¸ç©æ¸¸æˆã€‚

è¿™ä¹Ÿæ˜¯æˆ‘æœªå®ç°çš„ä¸€éƒ¨åˆ†ï¼Œå½“å‰çš„ä»£ç å®ç°äº†å¤šè½®å¯¹è¯å¹¶ä¸”åªä¿ç•™æœ€æ–°çš„10æ¡æ¶ˆæ¯ã€‚æ‰€ä»¥ï¼Œå¯¹äºæœ‰ç”¨çš„ä¿¡æ¯çš„å‚¨å­˜éœ€è¦å®ç°ã€‚

æˆ‘ä¸ºä»€ä¹ˆæ²¡æœ‰å®ç°è¿™ä¸€ç‚¹ï¼Œé‚£æ˜¯å› ä¸ºï¼Œä½ è¿˜æœ‰å¦å¤–ä¸€ç§æ–¹å¼ï¼Œæ¯”èµ·è®©æ¨¡å‹è‡ªå·±å‘æ˜æ¸¸æˆè§„åˆ™ï¼Œä½ ä¸ºä½ å°†è¦è®©æ¨¡å‹æ¸¸ç©çš„æ¸¸æˆï¼Œç¼–å†™ç‰¹å®šäºè¯¥æ¸¸æˆçš„æ¸¸æˆè§„åˆ™ä½œä¸ºç³»ç»Ÿæç¤ºè¯çš„ä¸€éƒ¨åˆ†ï¼Œä¼šå¢å¼ºæ¨¡å‹çš„æ¸¸ç©æ•ˆæœï¼Œå¹¶ä¸”å…äºè®©æ¨¡å‹è‡ªå·±å‘æ˜æ¸¸æˆç©æ³•äº§ç”Ÿçš„æ—¶é—´ã€tokenæˆæœ¬ã€‚

æˆ‘è®¤ä¸ºï¼Œå¯¹äºè®°äº‹æœ¬çš„å®ç°ï¼Œæ˜¯ä¸€ä¸ªæœ‰è¶£çš„å®ç°ï¼Œä½†æ˜¯ä¸ä¿è¯å®ç°ä¹‹åæ¨¡å‹çœŸçš„ä¼šå¾€é‡Œé¢å­˜ä¸€äº›æœ‰ç”¨çš„ä¸œè¥¿å¹¶åˆ©ç”¨èµ·æ¥ï¼Œè¿™æ˜¯ä¸€ä¸ªèµŒåšã€‚

æˆ‘ä¸è®¤ä¸ºä½¿ç”¨OpenAI GPT-4.1ç©æ¸¸æˆæ˜¯ä¸€ä¸ªå¥½ä¸»æ„ï¼Œæˆ‘éœ€è¦é€Ÿåº¦æ›´å¿«ã€æ€§èƒ½æ›´å¼ºçš„æ¨¡å‹ï¼Œæ‰èƒ½è®©æ¨¡å‹ç©æ¸¸æˆå˜å¾—æ›´å¥½ã€‚

ä½†æ˜¯ï¼Œä½œä¸ºä¸€ä¸ªdemoï¼Œå®ƒï¼ˆä»£ç ï¼‰éå¸¸ç§°èŒã€‚

**ä½ éœ€è¦ä¿®æ”¹WINDOWS_TITLEå¸¸é‡ï¼Œè¿™æ˜¯ä½ çš„æ¸¸æˆçª—å£åç§°**

ä¸‹é¢æ˜¯æ—¥å¿—å’Œæ¸¸æˆç•Œé¢ï¼š

![image](https://github.com/user-attachments/assets/57690c37-1ba0-4fe2-bb9e-c5d5af5b1a3e)

![image](https://github.com/user-attachments/assets/13f30333-83ef-4041-9ad3-6e3cddcf42be)


```python
import openai
import pyautogui
import time
import json
import base64
from pathlib import Path
from PIL import Image
import pygetwindow as gw
from pynput.keyboard import Key, Controller

# === é…ç½® ===
keyboard = Controller()
openaiclient = openai.OpenAI(base_url="https://text.pollinations.ai/openai",api_key="ä½ å¯ä»¥å•ç‹¬ç”³è¯·free keyæˆ–è€…ä½¿ç”¨ç©ºå­—ç¬¦ä¸²ï¼Œä¹Ÿè®¸å¯ä»¥å†™ç‚¹kfc111ä»€ä¹ˆçš„")  
SCREENSHOT_FILE = Path("screenshot.jpg")
WINDOWS_TITLE = "Rainy Day"
DEFAULT_LOOP_INTERVAL = 2
MIN_LOOP_INTERVAL = 0.5
MAX_LOOP_INTERVAL = 5.0

# === å·¥å…·å®šä¹‰ ===
tools = [
    {
        "type": "function",
        "function": {
            "name": "press_key",
            "description": "æ¨¡æ‹ŸæŒ‰ä¸‹é”®ç›˜æŒ‰é”®æ¥æ§åˆ¶æ¸¸æˆï¼Œå¯ä»¥è®¾ç½®æŒ‰é”®æŒç»­æ—¶é—´",
            "parameters": {
                "type": "object",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "è¦æŒ‰ä¸‹çš„é”®åã€‚å¸¸ç”¨é”®åŒ…æ‹¬ï¼šæ–¹å‘é”®(up/down/left/right)ã€ç©ºæ ¼é”®(space)ã€å­—æ¯é”®(a-z)ã€æ•°å­—é”®(0-9)ç­‰"
                    },
                    "duration": {
                        "type": "number",
                        "description": "æŒ‰ä½é”®çš„æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰ã€‚ç”¨äºé•¿æŒ‰æ“ä½œï¼Œå¦‚0.5è¡¨ç¤ºæŒ‰ä½0.5ç§’",
                        "default": 0.1
                    }
                },
                "required": ["key"]
            }
        }
    }
]

# === å·¥å…·å‡½æ•° ===
def screenshot_and_resize(path, window_title):
    windows = gw.getWindowsWithTitle(window_title)
    if not windows:
        raise Exception(f"æœªæ‰¾åˆ°æ ‡é¢˜ä¸º\"{window_title}\"çš„çª—å£")
    win = windows[0]
    win.activate()
    bbox = (win.left, win.top, win.width, win.height)
    img = pyautogui.screenshot(region=bbox)
    img = img.resize((960, 540))
    img.save(path, format="JPEG", quality=75)
    return path

def encode_image_to_base64(path):
    with open(path, "rb") as img_file:
        return base64.b64encode(img_file.read()).decode()
   
def execute_key_action(key: str, duration: float = 0.1):
    print(f"â¹ æŒ‰ä¸‹ {key} é”®ï¼ŒæŒç»­ {duration:.1f} ç§’")
    try:
        special_keys = {
            'space': Key.space,
            'enter': Key.enter,
            'return': Key.enter,
            'shift': Key.shift,
            'ctrl': Key.ctrl,
            'control': Key.ctrl,
            'alt': Key.alt,
            'esc': Key.esc,
            'escape': Key.esc,
            'tab': Key.tab,
            'up': Key.up,
            'â†‘': Key.up,
            'down': Key.down,
            'â†“': Key.down,
            'left': Key.left,
            'â†': Key.left,
            'right': Key.right,
            'â†’': Key.right,
            'backspace': Key.backspace,
            'delete': Key.delete,
            'home': Key.home,
            'end': Key.end,
            'pageup': Key.page_up,
            'pagedown': Key.page_down,
        }
        key_normalized = key.strip().lower()
        mapped_key = special_keys.get(key_normalized, key_normalized)
        keyboard.press(mapped_key)
        time.sleep(duration)
        keyboard.release(mapped_key)
    except Exception as e:
        print(f"âš ï¸ é”®ç›˜æ“ä½œå¤±è´¥: {e}")

# def execute_key_action(key: str, duration: float = 0.1):
#     print(f"â¹ æŒ‰ä¸‹ {key} é”®ï¼ŒæŒç»­ {duration:.1f} ç§’")
#     try:
#         pyautogui.keyDown(key)
#         time.sleep(duration)
#         pyautogui.keyUp(key)
#     except Exception as e:
#         print(f"âš ï¸ é”®ç›˜æ“ä½œå¤±è´¥: {e}")

def handle_tool_call(call):
    name = call.function.name
    args = json.loads(call.function.arguments)
    if name == "press_key":
        execute_key_action(args["key"], args.get("duration", 0.1))
        return True
    return False

# === ä¸»å¾ªç¯ ===
def main_loop():
    loop_interval = DEFAULT_LOOP_INTERVAL
    print("ğŸ® å¼€å§‹æ™ºèƒ½ä½“å¾ªç¯ï¼Œæ¯è½®é—´éš”", loop_interval, "ç§’")
    
    # åˆå§‹åŒ–å¯¹è¯å†å²ï¼Œä¿æŒä¸å˜
    conversation_history = [
    {
        "role": "system", 
        "content": """ä½ æ˜¯ä¸€ä½æ¸¸æˆæ™ºèƒ½ä½“ï¼Œèƒ½é€šè¿‡è§‚å¯Ÿæ¸¸æˆç”»é¢å¹¶æ§åˆ¶é”®ç›˜æ¥ç©æ¸¸æˆã€‚

ã€ç›®æ ‡ã€‘
1. åˆ†ææ¸¸æˆç”»é¢ï¼Œç†è§£æ¸¸æˆè§„åˆ™å’Œæ“ä½œæ–¹å¼
2. æ‰§è¡Œæ°å½“çš„æŒ‰é”®æ“ä½œä»¥å®Œæˆæ¸¸æˆç›®æ ‡
3. åœ¨æ¯æ¬¡å›å¤ä¸­æä¾›æ¸¸æˆçŠ¶æ€åˆ†æå’Œæ“ä½œç†ç”±

ã€è¾“å‡ºæ ¼å¼ã€‘
æ¯æ¬¡å›å¤å¿…é¡»åŒ…å«ä¸¤éƒ¨åˆ†ï¼š
1. æ–‡æœ¬åˆ†æï¼šç®€æ˜æè¿°å½“å‰æ¸¸æˆçŠ¶æ€ã€ä½ ç†è§£çš„è§„åˆ™å’Œä½ è¦æ‰§è¡Œæ“ä½œçš„åŸå› 
2. å·¥å…·è°ƒç”¨ï¼šä½¿ç”¨press_keyå·¥å…·æ‰§è¡Œä¸€æ¬¡é”®ç›˜æ“ä½œ

ç¤ºä¾‹å›å¤ï¼š
"æˆ‘çœ‹åˆ°è§’è‰²ç«™åœ¨å¹³å°è¾¹ç¼˜ï¼Œå‰æ–¹æœ‰éšœç¢ã€‚æ ¹æ®ä¹‹å‰çš„å°è¯•ï¼ŒæŒ‰ç©ºæ ¼é”®å¯ä»¥è·³è·ƒã€‚æˆ‘å°†æŒ‰ç©ºæ ¼é”®è·³è¿‡éšœç¢ç‰©ã€‚"

ã€é‡è¦è§„åˆ™ã€‘
- æ¯æ¬¡å›å¤å¿…é¡»åŒæ—¶åŒ…å«æ–‡æœ¬åˆ†æå’Œä¸€æ¬¡press_keyå·¥å…·è°ƒç”¨
- åŸºäºå½“å‰æ¸¸æˆç”»é¢çŠ¶æ€åšå‡ºå†³ç­–ï¼Œè€ƒè™‘ä¹‹å‰å­¦åˆ°çš„æ¸¸æˆè§„åˆ™
- å›å¤ç®€æ´æ˜äº†ï¼Œä¸è¶…è¿‡3-4å¥è¯"""
    }
]
    
    while True:
        try:
            # Step 1: æˆªå›¾å¤„ç†
            screenshot_and_resize(SCREENSHOT_FILE, WINDOWS_TITLE)
            image_b64 = encode_image_to_base64(SCREENSHOT_FILE)

            # Step 2: æ·»åŠ æ–°çš„ç”¨æˆ·æ¶ˆæ¯ï¼ˆæ¸¸æˆç”»é¢ï¼‰
            user_message = {
                "role": "user", 
                "content": [
                    {"type": "text", "text": "è¿™æ˜¯æ¸¸æˆå½“å‰ç”»é¢ï¼Œè¯·åˆ†ææƒ…å†µå¹¶æ‰§è¡Œä¸€æ¬¡åˆé€‚çš„æŒ‰é”®æ“ä½œã€‚"},
                    {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{image_b64}"}}
                ]
            }
            conversation_history.append(user_message)
            
            # ä¿®å¤çš„å†å²è£å‰ªé€»è¾‘ - æŒ‰æ¶ˆæ¯å¯¹ä¿ç•™å®Œæ•´
            if len(conversation_history) > 11:  # å†å²è¿‡é•¿éœ€è¦è£å‰ª
                # ä¿ç•™ç³»ç»Ÿæ¶ˆæ¯
                new_history = [conversation_history[0]]
                
                # ä»æœ€æ–°æ¶ˆæ¯å¼€å§‹ï¼ŒæŒ‰ç…§å®Œæ•´çš„è¯·æ±‚-å“åº”-å·¥å…·å¯¹æ·»åŠ 
                remaining_slots = 10  # 11ä¸ªæ€»æ§½ä½å‡å»ç³»ç»Ÿæ¶ˆæ¯
                i = len(conversation_history) - 1
                
                # ä¸´æ—¶å­˜å‚¨æ¶ˆæ¯ç»„
                message_groups = []
                
                # ä»æœ€æ–°åˆ°æœ€æ—©éå†æ¶ˆæ¯
                while i > 0 and remaining_slots > 0:
                    msg = conversation_history[i]
                    
                    # 1. å¤„ç†toolæ¶ˆæ¯
                    if msg["role"] == "tool":
                        tool_call_id = msg.get("tool_call_id")
                        # æ‰¾åˆ°å¯¹åº”çš„assistantæ¶ˆæ¯
                        for j in range(i-1, 0, -1):
                            if (conversation_history[j]["role"] == "assistant" and 
                                conversation_history[j].get("tool_calls") and 
                                any(call.id == tool_call_id for call in conversation_history[j].get("tool_calls", []))):
                                # æ‰¾åˆ°ç”¨æˆ·æ¶ˆæ¯(åœ¨assistantä¹‹å‰)
                                for k in range(j-1, 0, -1):
                                    if conversation_history[k]["role"] == "user":
                                        # æ‰¾åˆ°å®Œæ•´çš„ç”¨æˆ·-åŠ©æ‰‹-å·¥å…·å¯¹
                                        group = [conversation_history[k], conversation_history[j], msg]
                                        if len(group) <= remaining_slots:
                                            message_groups.append(group)
                                            remaining_slots -= len(group)
                                        i = k - 1
                                        break
                                break
                        
                    # 2. å¤„ç†ç‹¬ç«‹çš„ç”¨æˆ·-åŠ©æ‰‹å¯¹
                    elif msg["role"] == "assistant" and not msg.get("tool_calls"):
                        # å¯»æ‰¾å¯¹åº”çš„useræ¶ˆæ¯
                        for j in range(i-1, 0, -1):
                            if conversation_history[j]["role"] == "user":
                                group = [conversation_history[j], msg]
                                if len(group) <= remaining_slots:
                                    message_groups.append(group)
                                    remaining_slots -= len(group)
                                i = j - 1
                                break
                    
                    # 3. å¤„ç†å­¤ç«‹æ¶ˆæ¯æ—¶è·³è¿‡
                    else:
                        i -= 1
                
                # æŒ‰ä»æ—§åˆ°æ–°çš„é¡ºåºæ·»åŠ æ¶ˆæ¯ç»„
                message_groups.reverse()
                for group in message_groups:
                    new_history.extend(group)
                
                conversation_history = new_history
            
            # Step 3: è¯·æ±‚æ¨¡å‹
            # åœ¨è¯·æ±‚å‰éªŒè¯å†å²è®°å½•å®Œæ•´æ€§
            def validate_and_fix_history(history):
                # æ£€æŸ¥æ‰€æœ‰assistantå·¥å…·è°ƒç”¨æ˜¯å¦éƒ½æœ‰å“åº”
                fixed_history = []
                skip_ids = set()
                
                # ç¬¬ä¸€æ­¥ï¼šè¯†åˆ«æ²¡æœ‰å¯¹åº”å“åº”çš„å·¥å…·è°ƒç”¨ID
                for i, msg in enumerate(history):
                    if msg["role"] == "assistant" and msg.get("tool_calls"):
                        for call in msg.get("tool_calls", []):
                            has_response = False
                            for resp in history:
                                if resp["role"] == "tool" and resp.get("tool_call_id") == call.id:
                                    has_response = True
                                    break
                            if not has_response:
                                skip_ids.add(call.id)
                
                # ç¬¬äºŒæ­¥ï¼šè¿‡æ»¤å†å²è®°å½•
                for msg in history:
                    # è·³è¿‡æ²¡æœ‰å“åº”çš„assistantå·¥å…·è°ƒç”¨
                    if msg["role"] == "assistant" and msg.get("tool_calls"):
                        # æ·±æ‹·è´é¿å…ä¿®æ”¹åŸå§‹æ¶ˆæ¯
                        new_msg = dict(msg)
                        if "tool_calls" in new_msg:
                            new_tool_calls = []
                            for call in new_msg["tool_calls"]:
                                if call.id not in skip_ids:
                                    new_tool_calls.append(call)
                            
                            # å¦‚æœæ‰€æœ‰å·¥å…·è°ƒç”¨è¢«ç§»é™¤ï¼Œä¿ç•™æ–‡æœ¬å†…å®¹
                            if not new_tool_calls:
                                new_msg.pop("tool_calls", None)
                            else:
                                new_msg["tool_calls"] = new_tool_calls
                        
                        fixed_history.append(new_msg)
                    else:
                        # è·³è¿‡æ²¡æœ‰å¯¹åº”assistantçš„å·¥å…·å“åº”
                        if msg["role"] == "tool":
                            if msg.get("tool_call_id") in skip_ids:
                                continue
                        fixed_history.append(msg)
                
                return fixed_history
            
            # éªŒè¯å¹¶ä¿®å¤å†å²è®°å½•
            conversation_history = validate_and_fix_history(conversation_history)
            
            response = openaiclient.chat.completions.create(
                model="openai-large",
                messages=conversation_history,
                tools=tools,
                tool_choice="auto"
            )
            reply = response.choices[0].message
            
            # æ‰“å°æ¨¡å‹å›å¤
            print("ğŸ§  æ¨¡å‹å“åº”:", getattr(reply, "content", "").strip())

            # ä¿å­˜åŠ©æ‰‹å›å¤åˆ°å†å²
            assistant_message = {
                "role": "assistant",
                "content": getattr(reply, "content", ""),
                "tool_calls": reply.tool_calls if hasattr(reply, "tool_calls") else None
            }
            conversation_history.append(assistant_message)
            
            # Step 4: å·¥å…·è°ƒç”¨å’Œæ·»åŠ å·¥å…·å“åº”
            did_act = False
            if hasattr(reply, "tool_calls") and reply.tool_calls:
                for call in reply.tool_calls:
                    success = handle_tool_call(call)
                    did_act = did_act or success
                    
                    # æ— æ¡ä»¶æ·»åŠ å·¥å…·å“åº”æ¶ˆæ¯ï¼Œç¡®ä¿æ¯ä¸ªå·¥å…·è°ƒç”¨éƒ½æœ‰å“åº”
                    tool_response_message = {
                        "role": "tool",
                        "tool_call_id": call.id,
                        "content": json.dumps({"success": success})
                    }
                    conversation_history.append(tool_response_message)

            # Step 5: åŠ¨æ€é—´éš”è°ƒèŠ‚
            loop_interval = max(MIN_LOOP_INTERVAL, min(MAX_LOOP_INTERVAL, 1.0 if did_act else 3.0))

        except Exception as e:
            print("âš ï¸ é”™è¯¯ï¼š", e)

        time.sleep(loop_interval)

if __name__ == "__main__":
    main_loop()
```
